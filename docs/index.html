<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EdgeEventQueueRK: EdgeEventQueueRK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EdgeEventQueueRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="class_edge_event_queue_r_k.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueueRK</a> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <em>Store and forward publishing queue for Tracker Edge and Monitor Edge</em></p>
<ul>
<li>Repository: <a href="https://github.com/rickkas7/EdgeEventQueueRK">https://github.com/rickkas7/EdgeEventQueueRK</a></li>
<li>License: MIT (free for use in open or closed-source projects, including commercial projects)</li>
</ul>
<p>This library is intended to be used with Tracker Edge or Monitor Edge for implementing custom store and forward queueing.</p>
<h1>Setup</h1>
<h2>Tracker Edge</h2>
<ul>
<li>Add the <a class="el" href="class_edge_event_queue_r_k.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueueRK</a> library to your Tracker Edge product, typically using <b>Particle: Install Library</b> in Particle Workbench.</li>
<li>Add a global variable for your queue, typically in main.cpp. You will typically one have one, but you can have multiple queues.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_class" href="class_edge_event_queue_r_k.html">EdgeEventQueueRK</a> privateEventQueue;</div>
<div class="ttc" id="aclass_edge_event_queue_r_k_html"><div class="ttname"><a href="class_edge_event_queue_r_k.html">EdgeEventQueueRK</a></div><div class="ttdoc">Class for managing a private queue of events on the flash file system.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueueRK.h:38</div></div>
</div><!-- fragment --><ul>
<li>Initialize the library from <code>setup()</code>:</li>
</ul>
<div class="fragment"><div class="line">privateEventQueue</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue_r_k.html#a667cc1b7ba499d17975645bd742b48d6">withSizeLimit</a>(50 * 1024)</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue_r_k.html#a2595eb6aa256c26f3faca38d4208a087">withQueuePath</a>(<span class="stringliteral">&quot;/usr/testq&quot;</span>)</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue_r_k.html#a61426210e14e234ba4556817d62c336a">setup</a>();</div>
<div class="ttc" id="aclass_edge_event_queue_r_k_html_a2595eb6aa256c26f3faca38d4208a087"><div class="ttname"><a href="class_edge_event_queue_r_k.html#a2595eb6aa256c26f3faca38d4208a087">EdgeEventQueueRK::withQueuePath</a></div><div class="ttdeci">EdgeEventQueueRK &amp; withQueuePath(const char *path)</div><div class="ttdoc">Sets the queue path. Default is &quot;/usr/privateq&quot;. Typically put in &quot;/usr/&quot; directory.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueueRK.h:116</div></div>
<div class="ttc" id="aclass_edge_event_queue_r_k_html_a61426210e14e234ba4556817d62c336a"><div class="ttname"><a href="class_edge_event_queue_r_k.html#a61426210e14e234ba4556817d62c336a">EdgeEventQueueRK::setup</a></div><div class="ttdeci">int setup()</div><div class="ttdoc">Call during setup(), the main application setup function.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueueRK.cpp:15</div></div>
<div class="ttc" id="aclass_edge_event_queue_r_k_html_a667cc1b7ba499d17975645bd742b48d6"><div class="ttname"><a href="class_edge_event_queue_r_k.html#a667cc1b7ba499d17975645bd742b48d6">EdgeEventQueueRK::withSizeLimit</a></div><div class="ttdeci">EdgeEventQueueRK &amp; withSizeLimit(size_t sizeLimit)</div><div class="ttdoc">Set the disk queue size limit (in bytes). Default is 0 (not limited).</div><div class="ttdef"><b>Definition:</b> EdgeEventQueueRK.h:98</div></div>
</div><!-- fragment --><ul>
<li>Make sure you provide time to handle the queue by adding a call to <code>loop()</code>:</li>
</ul>
<div class="fragment"><div class="line">privateEventQueue.<a class="code hl_function" href="class_edge_event_queue_r_k.html#af94c1d61217eaae875bf76b8c171fd92">loop</a>();</div>
<div class="ttc" id="aclass_edge_event_queue_r_k_html_af94c1d61217eaae875bf76b8c171fd92"><div class="ttname"><a href="class_edge_event_queue_r_k.html#af94c1d61217eaae875bf76b8c171fd92">EdgeEventQueueRK::loop</a></div><div class="ttdeci">void loop()</div><div class="ttdoc">Call during loop(), the main application loop function.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueueRK.cpp:21</div></div>
</div><!-- fragment --><h2>Monitor Edge</h2>
<ul>
<li>Add the <a class="el" href="class_edge_event_queue_r_k.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueueRK</a> library to your Monitor Edge product, typically using <b>Particle: Install Library</b> in Particle Workbench.</li>
<li>Add a global variable for your queue, typically in user_setup.cpp. You will typically one have one, but you can have multiple queues.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_class" href="class_edge_event_queue_r_k.html">EdgeEventQueueRK</a> privateEventQueue;</div>
</div><!-- fragment --><ul>
<li>Initialize the library from <code>user_init()</code>:</li>
</ul>
<div class="fragment"><div class="line">privateEventQueue</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue_r_k.html#a667cc1b7ba499d17975645bd742b48d6">withSizeLimit</a>(50 * 1024)</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue_r_k.html#a2595eb6aa256c26f3faca38d4208a087">withQueuePath</a>(<span class="stringliteral">&quot;/usr/testq&quot;</span>)</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue_r_k.html#a61426210e14e234ba4556817d62c336a">setup</a>();</div>
</div><!-- fragment --><ul>
<li>Make sure you provide time to handle the queue by adding a call to <code>user_loop()</code>:</li>
</ul>
<div class="fragment"><div class="line">privateEventQueue.<a class="code hl_function" href="class_edge_event_queue_r_k.html#af94c1d61217eaae875bf76b8c171fd92">loop</a>();</div>
</div><!-- fragment --><h1>Using the library</h1>
<h2>Publishing using the queue</h2>
<p>To queue the data on the flash file system, use the <code>publish()</code> method.</p>
<div class="fragment"><div class="line">privateEventQueue.<a class="code hl_function" href="class_edge_event_queue_r_k.html#aa81376abfebcb5e26ebc2472cfcd953d">publish</a>(<span class="stringliteral">&quot;eventQueueTest&quot;</span>, eventData);</div>
<div class="ttc" id="aclass_edge_event_queue_r_k_html_aa81376abfebcb5e26ebc2472cfcd953d"><div class="ttname"><a href="class_edge_event_queue_r_k.html#aa81376abfebcb5e26ebc2472cfcd953d">EdgeEventQueueRK::publish</a></div><div class="ttdeci">int publish(const char *eventName, const char *eventData)</div><div class="ttdoc">Add an event to the publish queue on the flash file system.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueueRK.cpp:85</div></div>
</div><!-- fragment --><h2>Publishing without queueing</h2>
<p>Sometimes you will want to publish an event without using the queue, because the event is temporal and historical data is not useful if the device is currently offline.</p>
<p>To do this, use <code><a class="el" href="class_edge_event_queue_r_k.html#ac9af63b5275f0217b01f45ff8df51bc3" title="Publishes an event using the cloud service without using the disk queue.">EdgeEventQueueRK::cloudServicePublish</a></code>, which takes an eventName and eventData.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_edge_event_queue_r_k.html#ac9af63b5275f0217b01f45ff8df51bc3">EdgeEventQueueRK::cloudServicePublish</a>(<span class="stringliteral">&quot;eventQueueTest&quot;</span>, eventData);</div>
<div class="ttc" id="aclass_edge_event_queue_r_k_html_ac9af63b5275f0217b01f45ff8df51bc3"><div class="ttname"><a href="class_edge_event_queue_r_k.html#ac9af63b5275f0217b01f45ff8df51bc3">EdgeEventQueueRK::cloudServicePublish</a></div><div class="ttdeci">static int cloudServicePublish(const char *eventName, const char *eventData, PublishFlags publishFlags={}, size_t priority=0, std::function&lt; int(CloudServiceStatus)&gt; cb=0)</div><div class="ttdoc">Publishes an event using the cloud service without using the disk queue.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueueRK.cpp:119</div></div>
</div><!-- fragment --><p>This is preferable to directly using Particle.publish because it will interleave the emptying of the queue with sending your non-queued message and will not exceed the publish rate limit.</p>
<p>The full API is:</p>
<div class="fragment"><div class="line"><span class="comment">// PROTOTYPE - EdgeEventQueueRK</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> cloudServicePublish(<span class="keyword">const</span> <span class="keywordtype">char</span> *eventName, <span class="keyword">const</span> <span class="keywordtype">char</span> *eventData, PublishFlags publishFlags = {}, <span class="keywordtype">size_t</span> priority = 0, std::function&lt;int(CloudServiceStatus)&gt; cb = 0);</div>
</div><!-- fragment --><ul>
<li><code>eventName</code> The event name, as is used in <code>Particle.publish</code>.</li>
<li><code>eventData</code> The event data, as is used in <code>Particle.publish</code>.</li>
<li><code>publishFlags</code> Publish flags, as is used in Particle.publish. This is optional, and if omitted the default flags are used.</li>
<li><code>priority</code> 0 or 1. 0 is the default queue and 1 is the low priority queue.</li>
<li><code>cb</code> Callback function to be called on successful completion or error. Optional. Not called if an immediate error results in a non-zero result code; callback is only called if the return value is 0.</li>
<li>Returns <code>int</code> 0 on success or a non-zero error code</li>
</ul>
<p>The callback function has this prototype:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> callback(CloudServiceStatus status)</div>
</div><!-- fragment --><ul>
<li><code>status</code> is <code>particle::Error::NONE</code> (0) or an system error code on error</li>
</ul>
<p>Callback is a std::function so you can pass a lambda, which allows you to pass additional data via capture variables, or call a C++ class method and instance easily.</p>
<p>The eventName and eventValue are copied and do not need to remain valid until the callback is called. Once the cloudServicePublish call returns, the variables can go out of scope, so it's safe for them to be local variables on the stack.</p>
<p>Using cloudServicePublish interleaves your event with others in the system in a queue in RAM. The queue is finite in size (currently 8 elements per priority queue) and if the queue is full, -EBUSY (-16) is returned.</p>
<p>Note that this function does not use the disk queue! It's a low-level function used by the publish method in this class, or you can use it for your own purposes if you want to publish events that are not saved to disk if the device is currently offline. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
